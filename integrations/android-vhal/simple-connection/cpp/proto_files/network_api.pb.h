// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: network_api.proto

#ifndef PROTOBUF_INCLUDED_network_5fapi_2eproto
#define PROTOBUF_INCLUDED_network_5fapi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_network_5fapi_2eproto 

namespace protobuf_network_5fapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_network_5fapi_2eproto
namespace base {
class PublisherConfig;
class PublisherConfigDefaultTypeInternal;
extern PublisherConfigDefaultTypeInternal _PublisherConfig_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class SignalIds;
class SignalIdsDefaultTypeInternal;
extern SignalIdsDefaultTypeInternal _SignalIds_default_instance_;
class Signals;
class SignalsDefaultTypeInternal;
extern SignalsDefaultTypeInternal _Signals_default_instance_;
class SubscriberConfig;
class SubscriberConfigDefaultTypeInternal;
extern SubscriberConfigDefaultTypeInternal _SubscriberConfig_default_instance_;
}  // namespace base
namespace google {
namespace protobuf {
template<> ::base::PublisherConfig* Arena::CreateMaybeMessage<::base::PublisherConfig>(Arena*);
template<> ::base::Signal* Arena::CreateMaybeMessage<::base::Signal>(Arena*);
template<> ::base::SignalIds* Arena::CreateMaybeMessage<::base::SignalIds>(Arena*);
template<> ::base::Signals* Arena::CreateMaybeMessage<::base::Signals>(Arena*);
template<> ::base::SubscriberConfig* Arena::CreateMaybeMessage<::base::SubscriberConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace base {

// ===================================================================

class SubscriberConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:base.SubscriberConfig) */ {
 public:
  SubscriberConfig();
  virtual ~SubscriberConfig();

  SubscriberConfig(const SubscriberConfig& from);

  inline SubscriberConfig& operator=(const SubscriberConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscriberConfig(SubscriberConfig&& from) noexcept
    : SubscriberConfig() {
    *this = ::std::move(from);
  }

  inline SubscriberConfig& operator=(SubscriberConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriberConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscriberConfig* internal_default_instance() {
    return reinterpret_cast<const SubscriberConfig*>(
               &_SubscriberConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SubscriberConfig* other);
  friend void swap(SubscriberConfig& a, SubscriberConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriberConfig* New() const final {
    return CreateMaybeMessage<SubscriberConfig>(NULL);
  }

  SubscriberConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscriberConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscriberConfig& from);
  void MergeFrom(const SubscriberConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscriberConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .base.ClientId clientId = 1;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 1;
  private:
  const ::base::ClientId& _internal_clientid() const;
  public:
  const ::base::ClientId& clientid() const;
  ::base::ClientId* release_clientid();
  ::base::ClientId* mutable_clientid();
  void set_allocated_clientid(::base::ClientId* clientid);

  // .base.SignalIds signals = 2;
  bool has_signals() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 2;
  private:
  const ::base::SignalIds& _internal_signals() const;
  public:
  const ::base::SignalIds& signals() const;
  ::base::SignalIds* release_signals();
  ::base::SignalIds* mutable_signals();
  void set_allocated_signals(::base::SignalIds* signals);

  // bool onChange = 3;
  void clear_onchange();
  static const int kOnChangeFieldNumber = 3;
  bool onchange() const;
  void set_onchange(bool value);

  // @@protoc_insertion_point(class_scope:base.SubscriberConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::base::ClientId* clientid_;
  ::base::SignalIds* signals_;
  bool onchange_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_network_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignalIds : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:base.SignalIds) */ {
 public:
  SignalIds();
  virtual ~SignalIds();

  SignalIds(const SignalIds& from);

  inline SignalIds& operator=(const SignalIds& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalIds(SignalIds&& from) noexcept
    : SignalIds() {
    *this = ::std::move(from);
  }

  inline SignalIds& operator=(SignalIds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalIds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalIds* internal_default_instance() {
    return reinterpret_cast<const SignalIds*>(
               &_SignalIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SignalIds* other);
  friend void swap(SignalIds& a, SignalIds& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalIds* New() const final {
    return CreateMaybeMessage<SignalIds>(NULL);
  }

  SignalIds* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalIds>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalIds& from);
  void MergeFrom(const SignalIds& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalIds* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .base.SignalId signalId = 1;
  int signalid_size() const;
  void clear_signalid();
  static const int kSignalIdFieldNumber = 1;
  ::base::SignalId* mutable_signalid(int index);
  ::google::protobuf::RepeatedPtrField< ::base::SignalId >*
      mutable_signalid();
  const ::base::SignalId& signalid(int index) const;
  ::base::SignalId* add_signalid();
  const ::google::protobuf::RepeatedPtrField< ::base::SignalId >&
      signalid() const;

  // @@protoc_insertion_point(class_scope:base.SignalIds)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::base::SignalId > signalid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_network_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signals : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:base.Signals) */ {
 public:
  Signals();
  virtual ~Signals();

  Signals(const Signals& from);

  inline Signals& operator=(const Signals& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signals(Signals&& from) noexcept
    : Signals() {
    *this = ::std::move(from);
  }

  inline Signals& operator=(Signals&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signals& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signals* internal_default_instance() {
    return reinterpret_cast<const Signals*>(
               &_Signals_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Signals* other);
  friend void swap(Signals& a, Signals& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signals* New() const final {
    return CreateMaybeMessage<Signals>(NULL);
  }

  Signals* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signals>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signals& from);
  void MergeFrom(const Signals& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signals* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .base.Signal signal = 1;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 1;
  ::base::Signal* mutable_signal(int index);
  ::google::protobuf::RepeatedPtrField< ::base::Signal >*
      mutable_signal();
  const ::base::Signal& signal(int index) const;
  ::base::Signal* add_signal();
  const ::google::protobuf::RepeatedPtrField< ::base::Signal >&
      signal() const;

  // @@protoc_insertion_point(class_scope:base.Signals)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::base::Signal > signal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_network_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PublisherConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:base.PublisherConfig) */ {
 public:
  PublisherConfig();
  virtual ~PublisherConfig();

  PublisherConfig(const PublisherConfig& from);

  inline PublisherConfig& operator=(const PublisherConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PublisherConfig(PublisherConfig&& from) noexcept
    : PublisherConfig() {
    *this = ::std::move(from);
  }

  inline PublisherConfig& operator=(PublisherConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PublisherConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PublisherConfig* internal_default_instance() {
    return reinterpret_cast<const PublisherConfig*>(
               &_PublisherConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PublisherConfig* other);
  friend void swap(PublisherConfig& a, PublisherConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublisherConfig* New() const final {
    return CreateMaybeMessage<PublisherConfig>(NULL);
  }

  PublisherConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PublisherConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PublisherConfig& from);
  void MergeFrom(const PublisherConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublisherConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .base.Signals signals = 1;
  bool has_signals() const;
  void clear_signals();
  static const int kSignalsFieldNumber = 1;
  private:
  const ::base::Signals& _internal_signals() const;
  public:
  const ::base::Signals& signals() const;
  ::base::Signals* release_signals();
  ::base::Signals* mutable_signals();
  void set_allocated_signals(::base::Signals* signals);

  // .base.ClientId clientId = 2;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 2;
  private:
  const ::base::ClientId& _internal_clientid() const;
  public:
  const ::base::ClientId& clientid() const;
  ::base::ClientId* release_clientid();
  ::base::ClientId* mutable_clientid();
  void set_allocated_clientid(::base::ClientId* clientid);

  // int32 frequency = 3;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 3;
  ::google::protobuf::int32 frequency() const;
  void set_frequency(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:base.PublisherConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::base::Signals* signals_;
  ::base::ClientId* clientid_;
  ::google::protobuf::int32 frequency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_network_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:base.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  enum PayloadCase {
    kInteger = 2,
    kDouble = 3,
    kArbitration = 4,
    kEmpty = 6,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes raw = 5;
  void clear_raw();
  static const int kRawFieldNumber = 5;
  const ::std::string& raw() const;
  void set_raw(const ::std::string& value);
  #if LANG_CXX11
  void set_raw(::std::string&& value);
  #endif
  void set_raw(const char* value);
  void set_raw(const void* value, size_t size);
  ::std::string* mutable_raw();
  ::std::string* release_raw();
  void set_allocated_raw(::std::string* raw);

  // .base.SignalId id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  private:
  const ::base::SignalId& _internal_id() const;
  public:
  const ::base::SignalId& id() const;
  ::base::SignalId* release_id();
  ::base::SignalId* mutable_id();
  void set_allocated_id(::base::SignalId* id);

  // int64 timestamp = 7;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 integer = 2;
  private:
  bool has_integer() const;
  public:
  void clear_integer();
  static const int kIntegerFieldNumber = 2;
  ::google::protobuf::int64 integer() const;
  void set_integer(::google::protobuf::int64 value);

  // double double = 3;
  private:
  bool has_double_() const;
  public:
  void clear_double_();
  static const int kDoubleFieldNumber = 3;
  double double_() const;
  void set_double_(double value);

  // bool arbitration = 4;
  private:
  bool has_arbitration() const;
  public:
  void clear_arbitration();
  static const int kArbitrationFieldNumber = 4;
  bool arbitration() const;
  void set_arbitration(bool value);

  // bool empty = 6;
  private:
  bool has_empty() const;
  public:
  void clear_empty();
  static const int kEmptyFieldNumber = 6;
  bool empty() const;
  void set_empty(bool value);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:base.Signal)
 private:
  void set_has_integer();
  void set_has_double_();
  void set_has_arbitration();
  void set_has_empty();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr raw_;
  ::base::SignalId* id_;
  ::google::protobuf::int64 timestamp_;
  union PayloadUnion {
    PayloadUnion() {}
    ::google::protobuf::int64 integer_;
    double double__;
    bool arbitration_;
    bool empty_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_network_5fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SubscriberConfig

// .base.ClientId clientId = 1;
inline bool SubscriberConfig::has_clientid() const {
  return this != internal_default_instance() && clientid_ != NULL;
}
inline const ::base::ClientId& SubscriberConfig::_internal_clientid() const {
  return *clientid_;
}
inline const ::base::ClientId& SubscriberConfig::clientid() const {
  const ::base::ClientId* p = clientid_;
  // @@protoc_insertion_point(field_get:base.SubscriberConfig.clientId)
  return p != NULL ? *p : *reinterpret_cast<const ::base::ClientId*>(
      &::base::_ClientId_default_instance_);
}
inline ::base::ClientId* SubscriberConfig::release_clientid() {
  // @@protoc_insertion_point(field_release:base.SubscriberConfig.clientId)
  
  ::base::ClientId* temp = clientid_;
  clientid_ = NULL;
  return temp;
}
inline ::base::ClientId* SubscriberConfig::mutable_clientid() {
  
  if (clientid_ == NULL) {
    auto* p = CreateMaybeMessage<::base::ClientId>(GetArenaNoVirtual());
    clientid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:base.SubscriberConfig.clientId)
  return clientid_;
}
inline void SubscriberConfig::set_allocated_clientid(::base::ClientId* clientid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(clientid_);
  }
  if (clientid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clientid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clientid, submessage_arena);
    }
    
  } else {
    
  }
  clientid_ = clientid;
  // @@protoc_insertion_point(field_set_allocated:base.SubscriberConfig.clientId)
}

// .base.SignalIds signals = 2;
inline bool SubscriberConfig::has_signals() const {
  return this != internal_default_instance() && signals_ != NULL;
}
inline void SubscriberConfig::clear_signals() {
  if (GetArenaNoVirtual() == NULL && signals_ != NULL) {
    delete signals_;
  }
  signals_ = NULL;
}
inline const ::base::SignalIds& SubscriberConfig::_internal_signals() const {
  return *signals_;
}
inline const ::base::SignalIds& SubscriberConfig::signals() const {
  const ::base::SignalIds* p = signals_;
  // @@protoc_insertion_point(field_get:base.SubscriberConfig.signals)
  return p != NULL ? *p : *reinterpret_cast<const ::base::SignalIds*>(
      &::base::_SignalIds_default_instance_);
}
inline ::base::SignalIds* SubscriberConfig::release_signals() {
  // @@protoc_insertion_point(field_release:base.SubscriberConfig.signals)
  
  ::base::SignalIds* temp = signals_;
  signals_ = NULL;
  return temp;
}
inline ::base::SignalIds* SubscriberConfig::mutable_signals() {
  
  if (signals_ == NULL) {
    auto* p = CreateMaybeMessage<::base::SignalIds>(GetArenaNoVirtual());
    signals_ = p;
  }
  // @@protoc_insertion_point(field_mutable:base.SubscriberConfig.signals)
  return signals_;
}
inline void SubscriberConfig::set_allocated_signals(::base::SignalIds* signals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signals_;
  }
  if (signals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:base.SubscriberConfig.signals)
}

// bool onChange = 3;
inline void SubscriberConfig::clear_onchange() {
  onchange_ = false;
}
inline bool SubscriberConfig::onchange() const {
  // @@protoc_insertion_point(field_get:base.SubscriberConfig.onChange)
  return onchange_;
}
inline void SubscriberConfig::set_onchange(bool value) {
  
  onchange_ = value;
  // @@protoc_insertion_point(field_set:base.SubscriberConfig.onChange)
}

// -------------------------------------------------------------------

// SignalIds

// repeated .base.SignalId signalId = 1;
inline int SignalIds::signalid_size() const {
  return signalid_.size();
}
inline ::base::SignalId* SignalIds::mutable_signalid(int index) {
  // @@protoc_insertion_point(field_mutable:base.SignalIds.signalId)
  return signalid_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::base::SignalId >*
SignalIds::mutable_signalid() {
  // @@protoc_insertion_point(field_mutable_list:base.SignalIds.signalId)
  return &signalid_;
}
inline const ::base::SignalId& SignalIds::signalid(int index) const {
  // @@protoc_insertion_point(field_get:base.SignalIds.signalId)
  return signalid_.Get(index);
}
inline ::base::SignalId* SignalIds::add_signalid() {
  // @@protoc_insertion_point(field_add:base.SignalIds.signalId)
  return signalid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::base::SignalId >&
SignalIds::signalid() const {
  // @@protoc_insertion_point(field_list:base.SignalIds.signalId)
  return signalid_;
}

// -------------------------------------------------------------------

// Signals

// repeated .base.Signal signal = 1;
inline int Signals::signal_size() const {
  return signal_.size();
}
inline void Signals::clear_signal() {
  signal_.Clear();
}
inline ::base::Signal* Signals::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:base.Signals.signal)
  return signal_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::base::Signal >*
Signals::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:base.Signals.signal)
  return &signal_;
}
inline const ::base::Signal& Signals::signal(int index) const {
  // @@protoc_insertion_point(field_get:base.Signals.signal)
  return signal_.Get(index);
}
inline ::base::Signal* Signals::add_signal() {
  // @@protoc_insertion_point(field_add:base.Signals.signal)
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::base::Signal >&
Signals::signal() const {
  // @@protoc_insertion_point(field_list:base.Signals.signal)
  return signal_;
}

// -------------------------------------------------------------------

// PublisherConfig

// .base.Signals signals = 1;
inline bool PublisherConfig::has_signals() const {
  return this != internal_default_instance() && signals_ != NULL;
}
inline void PublisherConfig::clear_signals() {
  if (GetArenaNoVirtual() == NULL && signals_ != NULL) {
    delete signals_;
  }
  signals_ = NULL;
}
inline const ::base::Signals& PublisherConfig::_internal_signals() const {
  return *signals_;
}
inline const ::base::Signals& PublisherConfig::signals() const {
  const ::base::Signals* p = signals_;
  // @@protoc_insertion_point(field_get:base.PublisherConfig.signals)
  return p != NULL ? *p : *reinterpret_cast<const ::base::Signals*>(
      &::base::_Signals_default_instance_);
}
inline ::base::Signals* PublisherConfig::release_signals() {
  // @@protoc_insertion_point(field_release:base.PublisherConfig.signals)
  
  ::base::Signals* temp = signals_;
  signals_ = NULL;
  return temp;
}
inline ::base::Signals* PublisherConfig::mutable_signals() {
  
  if (signals_ == NULL) {
    auto* p = CreateMaybeMessage<::base::Signals>(GetArenaNoVirtual());
    signals_ = p;
  }
  // @@protoc_insertion_point(field_mutable:base.PublisherConfig.signals)
  return signals_;
}
inline void PublisherConfig::set_allocated_signals(::base::Signals* signals) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signals_;
  }
  if (signals) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signals = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signals, submessage_arena);
    }
    
  } else {
    
  }
  signals_ = signals;
  // @@protoc_insertion_point(field_set_allocated:base.PublisherConfig.signals)
}

// .base.ClientId clientId = 2;
inline bool PublisherConfig::has_clientid() const {
  return this != internal_default_instance() && clientid_ != NULL;
}
inline const ::base::ClientId& PublisherConfig::_internal_clientid() const {
  return *clientid_;
}
inline const ::base::ClientId& PublisherConfig::clientid() const {
  const ::base::ClientId* p = clientid_;
  // @@protoc_insertion_point(field_get:base.PublisherConfig.clientId)
  return p != NULL ? *p : *reinterpret_cast<const ::base::ClientId*>(
      &::base::_ClientId_default_instance_);
}
inline ::base::ClientId* PublisherConfig::release_clientid() {
  // @@protoc_insertion_point(field_release:base.PublisherConfig.clientId)
  
  ::base::ClientId* temp = clientid_;
  clientid_ = NULL;
  return temp;
}
inline ::base::ClientId* PublisherConfig::mutable_clientid() {
  
  if (clientid_ == NULL) {
    auto* p = CreateMaybeMessage<::base::ClientId>(GetArenaNoVirtual());
    clientid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:base.PublisherConfig.clientId)
  return clientid_;
}
inline void PublisherConfig::set_allocated_clientid(::base::ClientId* clientid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(clientid_);
  }
  if (clientid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      clientid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, clientid, submessage_arena);
    }
    
  } else {
    
  }
  clientid_ = clientid;
  // @@protoc_insertion_point(field_set_allocated:base.PublisherConfig.clientId)
}

// int32 frequency = 3;
inline void PublisherConfig::clear_frequency() {
  frequency_ = 0;
}
inline ::google::protobuf::int32 PublisherConfig::frequency() const {
  // @@protoc_insertion_point(field_get:base.PublisherConfig.frequency)
  return frequency_;
}
inline void PublisherConfig::set_frequency(::google::protobuf::int32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:base.PublisherConfig.frequency)
}

// -------------------------------------------------------------------

// Signal

// .base.SignalId id = 1;
inline bool Signal::has_id() const {
  return this != internal_default_instance() && id_ != NULL;
}
inline const ::base::SignalId& Signal::_internal_id() const {
  return *id_;
}
inline const ::base::SignalId& Signal::id() const {
  const ::base::SignalId* p = id_;
  // @@protoc_insertion_point(field_get:base.Signal.id)
  return p != NULL ? *p : *reinterpret_cast<const ::base::SignalId*>(
      &::base::_SignalId_default_instance_);
}
inline ::base::SignalId* Signal::release_id() {
  // @@protoc_insertion_point(field_release:base.Signal.id)
  
  ::base::SignalId* temp = id_;
  id_ = NULL;
  return temp;
}
inline ::base::SignalId* Signal::mutable_id() {
  
  if (id_ == NULL) {
    auto* p = CreateMaybeMessage<::base::SignalId>(GetArenaNoVirtual());
    id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:base.Signal.id)
  return id_;
}
inline void Signal::set_allocated_id(::base::SignalId* id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(id_);
  }
  if (id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:base.Signal.id)
}

// int64 integer = 2;
inline bool Signal::has_integer() const {
  return payload_case() == kInteger;
}
inline void Signal::set_has_integer() {
  _oneof_case_[0] = kInteger;
}
inline void Signal::clear_integer() {
  if (has_integer()) {
    payload_.integer_ = GOOGLE_LONGLONG(0);
    clear_has_payload();
  }
}
inline ::google::protobuf::int64 Signal::integer() const {
  // @@protoc_insertion_point(field_get:base.Signal.integer)
  if (has_integer()) {
    return payload_.integer_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Signal::set_integer(::google::protobuf::int64 value) {
  if (!has_integer()) {
    clear_payload();
    set_has_integer();
  }
  payload_.integer_ = value;
  // @@protoc_insertion_point(field_set:base.Signal.integer)
}

// double double = 3;
inline bool Signal::has_double_() const {
  return payload_case() == kDouble;
}
inline void Signal::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void Signal::clear_double_() {
  if (has_double_()) {
    payload_.double__ = 0;
    clear_has_payload();
  }
}
inline double Signal::double_() const {
  // @@protoc_insertion_point(field_get:base.Signal.double)
  if (has_double_()) {
    return payload_.double__;
  }
  return 0;
}
inline void Signal::set_double_(double value) {
  if (!has_double_()) {
    clear_payload();
    set_has_double_();
  }
  payload_.double__ = value;
  // @@protoc_insertion_point(field_set:base.Signal.double)
}

// bool arbitration = 4;
inline bool Signal::has_arbitration() const {
  return payload_case() == kArbitration;
}
inline void Signal::set_has_arbitration() {
  _oneof_case_[0] = kArbitration;
}
inline void Signal::clear_arbitration() {
  if (has_arbitration()) {
    payload_.arbitration_ = false;
    clear_has_payload();
  }
}
inline bool Signal::arbitration() const {
  // @@protoc_insertion_point(field_get:base.Signal.arbitration)
  if (has_arbitration()) {
    return payload_.arbitration_;
  }
  return false;
}
inline void Signal::set_arbitration(bool value) {
  if (!has_arbitration()) {
    clear_payload();
    set_has_arbitration();
  }
  payload_.arbitration_ = value;
  // @@protoc_insertion_point(field_set:base.Signal.arbitration)
}

// bool empty = 6;
inline bool Signal::has_empty() const {
  return payload_case() == kEmpty;
}
inline void Signal::set_has_empty() {
  _oneof_case_[0] = kEmpty;
}
inline void Signal::clear_empty() {
  if (has_empty()) {
    payload_.empty_ = false;
    clear_has_payload();
  }
}
inline bool Signal::empty() const {
  // @@protoc_insertion_point(field_get:base.Signal.empty)
  if (has_empty()) {
    return payload_.empty_;
  }
  return false;
}
inline void Signal::set_empty(bool value) {
  if (!has_empty()) {
    clear_payload();
    set_has_empty();
  }
  payload_.empty_ = value;
  // @@protoc_insertion_point(field_set:base.Signal.empty)
}

// bytes raw = 5;
inline void Signal::clear_raw() {
  raw_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Signal::raw() const {
  // @@protoc_insertion_point(field_get:base.Signal.raw)
  return raw_.GetNoArena();
}
inline void Signal::set_raw(const ::std::string& value) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:base.Signal.raw)
}
#if LANG_CXX11
inline void Signal::set_raw(::std::string&& value) {
  
  raw_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:base.Signal.raw)
}
#endif
inline void Signal::set_raw(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:base.Signal.raw)
}
inline void Signal::set_raw(const void* value, size_t size) {
  
  raw_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:base.Signal.raw)
}
inline ::std::string* Signal::mutable_raw() {
  
  // @@protoc_insertion_point(field_mutable:base.Signal.raw)
  return raw_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_raw() {
  // @@protoc_insertion_point(field_release:base.Signal.raw)
  
  return raw_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_raw(::std::string* raw) {
  if (raw != NULL) {
    
  } else {
    
  }
  raw_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw);
  // @@protoc_insertion_point(field_set_allocated:base.Signal.raw)
}

// int64 timestamp = 7;
inline void Signal::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Signal::timestamp() const {
  // @@protoc_insertion_point(field_get:base.Signal.timestamp)
  return timestamp_;
}
inline void Signal::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:base.Signal.timestamp)
}

inline bool Signal::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Signal::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Signal::PayloadCase Signal::payload_case() const {
  return Signal::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace base

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_network_5fapi_2eproto
